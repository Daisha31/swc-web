generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model AuthenticationNonce {
  id String @id
}

// A user can interact with our platform multiple ways. 
// Sometimes that user will be signing up via coinbase, 
// sometimes a user will be signing up via a wallet on the website, 
// sometimes they won't be logged in at all but we'll need to cache a session id for them so that if they log in with a eth address later we can associate their actions with the new address. 
// We'll need to track these different "users" with their own respective metadata, and try to join these related models with a InferredUser table
model InferredUser {
  id              String   @id @default(uuid())
  datetimeUpdated DateTime @updatedAt @map("datetime_updated")
  datetimeCreated DateTime @default(now()) @map("datetime_created")

  sessionUsers       SessionUser[]
  cryptoAddressUsers CryptoAddressUser[]
  userActions        UserAction[]
}

// TODO, figure out how Coinbase auth handoff fits in to the equation here

// A "user" that is performing actions on our platform but has not logged in to any system yet.
// A session user will only be created/associated with events if a different authenticatd user type is not also associated with the event
model SessionUser {
  id              String        @id @default(uuid())
  inferredUserId  String?       @map("inferred_user_id")
  inferredUser    InferredUser? @relation(fields: [inferredUserId], references: [id])
  datetimeUpdated DateTime      @updatedAt @map("datetime_updated")
  datetimeCreated DateTime      @default(now()) @map("datetime_created")

  userActions UserAction[]

  @@index([inferredUserId])
}

// TODO determine how google places constructs addresses and map this field to that structure to ensure we're internationalizing the way we persist addresses
model Address {
  id              String   @id @default(uuid())
  googlePlacesId  String?  @map("google_places_id")
  streetAddress1  String   @map("street_address_1")
  streetAddress2  String   @default("") @map("street_address_2")
  city            String
  state           String
  zipCode         String   @map("zip_code")
  countryCode     String
  datetimeUpdated DateTime @updatedAt @map("datetime_updated")
  datetimeCreated DateTime @default(now()) @map("datetime_created")

  userActionEmails UserActionEmail[]
  cryptoAddressUser CryptoAddressUser[]
}

// enum Web3AddressCustodian {
//   SELF_CUSTODY
//   THIRDWEB
// }

// Using ThirdWeb a user can create multiple "accounts", one per wallet. They can also have some that are self-custodied, and some that are being custodied by ThirdWeb (email, google login, etc)
model CryptoAddressUser {
  id                      String       @id @default(uuid())
  cryptoAddress                 String       @unique
  name                    String       @map("name") @default("")
  email                   String       @map("email") @default("")
  phoneNumber             String       @map("phone_number") @default("")
  address                 Address?      @relation(fields: [addressId], references: [id])
  addressId               String?       @map("address_id")
  // TODO figure out how to identify this
  // initialCustodian Web3AddressCustodian
  inferredUserId          String       @map("inferred_user_id")
  inferredUser            InferredUser @relation(fields: [inferredUserId], references: [id])
  datetimeUpdated         DateTime     @updatedAt @map("datetime_updated")
  datetimeCreated         DateTime     @default(now()) @map("datetime_created")
  sampleDatabaseIncrement Int          @default(0) // TODO delete
  isPubliclyVisible Boolean @map("is_publicly_visible")

  userActions UserAction[]

  // TODO determine if we need a network (ETH, SOL, etc) enum here. Can always add later
  @@index([inferredUserId])
  @@index([addressId])
}

enum UserActionType {
  EMAIL
  CALL
  DONATION
  OPT_IN
  TWEET
  NFT_MINT
}

model UserAction {
  id                  String             @id @default(uuid())
  // Because a user could be in a number of different states (logged in, not logged in, etc) we want to track the different types of users that could be performing an action
  // We will retroactively foreign key to the appropriate InferredUser if one is not attached on create but later added
  inferredUserId      String?            @map("inferred_user_id")
  inferredUser        InferredUser?      @relation(fields: [inferredUserId], references: [id])
  cryptoAddressUserId String?            @map("crypto_address_user_id")
  cryptoAddressUser   CryptoAddressUser? @relation(fields: [cryptoAddressUserId], references: [id])
  sessionUserId       String?            @map("session_user_id")
  sessionUser         SessionUser?       @relation(fields: [sessionUserId], references: [id])
  // because some of these will be backfilled from other data sources, we want to differentiate between the datetime the action was performed and the datetime we recorded it in this db
  datetimeOccurred    DateTime           @map("datetime_occurred")
  datetimeUpdated     DateTime           @updatedAt @map("datetime_updated")
  datetimeCreated     DateTime           @default(now()) @map("datetime_created")
  nftMintId           String?            @map("nft_mint_id")
  nftMint             NFTMint?           @relation(fields: [nftMintId], references: [id])
  actionType                UserActionType     @map("action_type")

  // We'll need logic to validate and verify only one action type is every associated with a UserAction
  userActionEmail    UserActionEmail?
  userActionCall     UserActionCall?
  userActionDonation UserActionDonation?
  userActionOptIn    UserActionOptIn?

  @@index([inferredUserId])
  @@index([cryptoAddressUserId])
  @@index([sessionUserId])
  @@index([nftMintId])
}

enum UserActionOptInType {
 SWC_SIGN_UP
}

// TODO i assume this is where we'll store their email if they opt in via Coinbase app
model UserActionOptIn {
  id                        String                     @id @default(uuid())
  userAction                UserAction                 @relation(fields: [id], references: [id])
  optInType                 UserActionOptInType        @map("opt_in_type")
  @@index([id])
}

model UserActionEmail {
  id                        String                     @id @default(uuid())
  userAction                UserAction                 @relation(fields: [id], references: [id])
  // TODO determine if these need to be nullable in the future
  zipCode                   String                     @map("zip_code")
  senderEmail               String
  fullName                  String                     @map("full_name")
  phoneNumber               String                     @map("phone_number")
  address                   Address                    @relation(fields: [addressId], references: [id])
  addressId                 String                     @map("address_id")
  userActionEmailRecipients UserActionEmailRecipient[]

  @@index([id])
  @@index([addressId])
}

model UserActionEmailRecipient {
  id                String          @id @default(uuid())
  userActionEmailId String          @map("user_action_email_id")
  userActionEmail   UserActionEmail @relation(fields: [userActionEmailId], references: [id])
  email             String
  dtsiSlug          String          @map("dtsi_slug")

  @@index([userActionEmailId])
}

model UserActionCall {
  id                   String     @id @default(uuid())
  userAction           UserAction @relation(fields: [id], references: [id])
  // TODO determine if these need to be nullable in the future
  recipientDtsiSlug    String     @map("recipient_dtsi_slug")
  recipientPhoneNumber String     @map("recipient_phone_number")

  @@index([id])
}

model UserActionDonation {
  id                 String     @id @default(uuid())
  userAction         UserAction @relation(fields: [id], references: [id])
  // TODO determine if these need to be nullable in the future
  amount             Decimal    @map("amount")
  amountCurrencyCode String     @map("amount_currency_code")
  amountUsd          Decimal    @map("amount_usd")

  @@index([id])
}

enum NFTCurrency {
  ETH
}

// TODO determine if this actually should be a model or just an enum
// my gut is that we want to be able to spin up new mints in the future without having to migrate the db
// if that's the case then we want a freestanding model
model NFT {
  id               String                   @id @default(uuid())
  name             String
  cost             Decimal                  @map("cost")
  costCurrencyCode NFTCurrency @map("cost_currency_code")
  datetimeUpdated  DateTime                 @updatedAt @map("datetime_updated")
  datetimeCreated  DateTime                 @default(now()) @map("datetime_created")

  nftMint NFTMint[]
  // TODO Web3 info about address/contract/etc/price (img)

  @@index([id])
}

model NFTMint {
  id               String                   @id @default(uuid())
  nftId            String                   @map("nft_id")
  nft              NFT         @relation(fields: [nftId], references: [id])
  datetimeUpdated  DateTime                 @updatedAt @map("datetime_updated")
  datetimeCreated  DateTime                 @default(now()) @map("datetime_created")
  costAtMint             Decimal                  @map("cost_at_mint")
  costAtMintCurrencyCode NFTCurrency @map("cost_at_mint_currency_code")
  constAtMintUsd         Decimal                  @map("cost_at_mint_usd")

  userActions UserAction[]

  @@index([id])
  @@index([nftId])
}

